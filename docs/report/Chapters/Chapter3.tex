% Chapter 3

\chapter{Number Theory and Public-key Cryptography}
\label{Chapter3}
\lhead{Chapter 3. \emph{Number Theory and Public-key Cryptography}} 

\section{Overview}

Number theory, the unit of mathematics that studies integers and their properties, was once a predominantly useless area. However, as cryptographic algorithms became more prevalent, particularly schemes that require the use of large prime numbers. We have already covered the notation used in the majority of number theoretic algorithms, and so this section will build upon this and discuss basic concepts and applications: modular arithmetic, prime number generation, and factorisation.

In this section we will make the assumption that any attackers who may try to break our algorithms or eavesdrop on our messages are extremely powerful and capable, and so we will discuss algorithms with regards to their tractability -- in this case, whether or not a significant percentage of all instances of a problem can be solved in polynomial time.

Throughout, where appropriate, programming examples are provided in Java.

\section{Modular Arithmetic and Congruence}

  As we know, the core concept of modular arithmetic is to return the remainder of the division of two integers, represented as $a(mod \ n)$. It is said that $b$ is congruent to $a(mod \ n)$ if $b \equiv a(mod \ n)$. Congruences play a great part in cryptography -- one of the very first uses was the Caesar Cipher. Messages were made secret -- encrypted -- by shifting letters forward by an integer $n$, where $0 < n \leq 25$.
  
  Given a sequence of characters $\{A,B,C,...,Z\}$ where each letter is represented by a number $\{0,1,2,...,25\}$. Defined by a function $f(n)$, where $n$ is the integer representation of a character:
  
    \begin{center}
       $f(n) = (n + x) \ mod \ 26$
    \end{center}
    
  where $x$ is the number of characters to shift by.
  
  This is a very simple example of how congruences can be used in cryptography. As we will see in the public-key section, congruences can be applied in a similarly simple way as a vital component part of a far more complex algorithm.
  
  Indeed, although the technicalities of this are not relevant, congruences can even be used to generate pseudo-random numbers.

\section{Prime Numbers}

Primes have already been covered, however they are a deeply fascinating subject with many current open problems and conjectures. For example, Goldbach's Conjecture states that every odd integer $n$, where $n > 2$, is the sum of two primes. This is intriguing because so far this has been \emph{verified} for integers up to $2 \times 10^{17}$, but mathematicians have not yet found a formal proof for this, and despite this they continue to believe it to be true \cite{Rosen:2007aa}.

We, however, will be using them for a far more interesting\footnote{http://xkcd.com/247/} purpose: cryptography based around the intractability of factoring very large composite numbers into their smaller non-trivial prime divisors.

  \subsection{Generation}
  
  First and foremost, we must devise an efficient method for generating the prime numbers. Although generating the keys for use in prime number based algorithms is generally not done on a regular basis, it is still a complex task to complete in a reasonable amount of time. As it stands, a number of algorithms already exist (and have done for many hundreds of years) for this purpose, though in a different sense: it is relatively easy to generate small sequences of small primes, however to obtain large, individual primes the fastest method is to generate probable primes using primality tests.
  
    \subsubsection{Probable, Provable and Pseudo-primes}
    
    There is a subtle yet significant difference between the types of primes that can be generated.
    
      \paragraph{Probable Primes}
  
    \subsubsection{Sieves}
    
    \subsubsection{Fermat's Little Theorem}
    
    \subsubsection{Miller--Rabin Primality Test}
    
    \subsubsection{Solovay--Strassen Primality Test}
    
    \subsubsection{AKS Primality Test}
  
    \subsubsection{A Note on Random Number Generators}
    
    The random number generators mentioned thus far, and all used later, cannot be considered \emph{truly} random. They are known as \emph{pseudo-random number generators} -- sequences generated deterministically based on a seed value. The sequences are produced algorithmically based on a relatively small set of values, Generally these sequence can be considered \emph{practically} random for most uses, assuming the seed is not publicly known and is truly random.
    
    Most truly random numbers are generated by analysing physical methods, such as nuclear decay or cosmic background radiation. However, typically this tends to be costly and is usually reserved only for applications that explicitly need high-security, non-deterministic random numbers. Recently the technology has become more available due to the widespread availability of online services -- for example, RANDOM.ORG\footnote{http://random.org} offers an API that returns truly random numbers on request. This naturally comes with its own security downsides, but can be used for non-cryptographic applications. Even then, RANDOM.ORG charges for clients that go over a quota of requests.
    
    The generation and application of random numbers is an extensive and current area of research. For the purposes of the cryptographic utilities to be developer, and the Enigma application, we will be used the \emph{Java SDK} class \verb!SecureRandom!. \verb!SecureRandom! is a cryptographically strong pseudo-random number generator that complies and follows tests specified by FIPS-140-2\footnote{Section 4.9.1}, and also uses non-deterministic seed material, as defined by \emph{RFC 1750}\footnote{http://www.faqs.org/rfcs/rfc1750.html}. Assuming the proper use of this class, it is about as close as we will get to generating secure, non-deterministic random numbers without resorting to physical methods.
    
    In short, and for our purposes, the generation of secure random numbers is based around maintaining the secrecy of a truly random seed on which a random sequence can be generated.

\section{Integers}

  \subsection{Factorisation}

\section{Public-key Cryptography}

  \subsection{RSA}
  
  So far we have only covered the concepts of number theory and how they're used in cryptography. In this section we will discuss exactly how they are implemented, and go in to greater detail about the algorithms and techniques required.
  
    \subsubsection{Implementation}
    
    \subsubsection{Textbooks and OAEP}

  \subsection{Diffie-Hellman}
  
    \subsubsection{Implementation}
  
\section{Other Variations of Public-key Cryptography}