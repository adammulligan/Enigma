% Chapter 7

\chapter{Cryptanalysis} 
\label{Chapter7}
\lhead{Chapter 7. \emph{Cryptanalyis}} 

\section{Public-key Cryptography}

  \subsection{RSA}
    
    A distinction must be made between the security of the RSA \emph{algorithm} and the RSA \emph{system}. This is known as semantic security \cite{Goldwasse:1990aa}, the use of other non-algorithmic techniques to resist attacks and make it, for example, difficult to recover information from the public key. As we discussed in Chapter 3, standards exist such as RSA-OAEP that introduce elements of randomness in to the RSA algorithm that limit certain basic attacks -- this is the RSA algorithm implemented in to a cryptosystem. The RSA algorithm itself is distinct from this at is the core mathematics, rather than an implementation of a secure system.
    
    In this section, we will discuss both attacks on the RSA \emph{algorithm} and attacks against RSA \emph{systems}, such as the one we have implemented.
    
    \subsubsection{Brute Force}
    
      The first attack we should mention is known as the \emph{brute-force} attack: factorising the integer modulus $N$ to determine the prime numbers used to generate the keys. This has been discussed throughout the paper, and due to the simplicity (to an extent) of the attack, we will not extensively cover it. It is interesting to note that there are no (publicly available) efficient algorithms with an acceptable running time for factoring large prime multiples. The current fastest algorithm is the \emph{General Number Field Sieve}, which runs on $\exp\left( \left(\sqrt[3]{\frac{64}{9}} + o(1)\right)(\log n)^{\frac{1}{3}}(\log \log n)^{\frac{2}{3}}\right) =L_n\left[\frac{1}{3},\sqrt[3]{\frac{64}{9}}\right]$ time, with an $n$-bit integer. See \cite{Briggs:1998aa} for an interesting introduction to GNFS.
      
      If an algorithm for factoring large integers in reasonable time periods is ever discovered, RSA will be rendered entirely insecure. However, until then we will only consider attacks that can decrypt RSA ciphertext \emph{without} factoring the modulus $N$.
    
    \subsubsection{Elementary Attacks}
    
      \paragraph{Small Exponent}
  
        \subparagraph{Private Exponent}
        \subparagraph{Public Exponent}
        
          It is common belief that using a small encryption exponent $e$ does not adversely affect the capabilities of the RSA algorithm. For example, it is suggested $e=3$.
          
          This is best shown as an example. If Alice wishes to send a message $m$ to three associates with the public moduli $n_{\{1,2,3\}}$ and exponent $e=3$, she would send $c_i = m^3$ mod $n_i$. Through a eavesdropping, an attacker Mallory could use Gauss's Algorithm all three values of $c$ to find:
          
          \[
          	\left\{
          	\begin{array}{ll}
                    x \equiv c_1 \  mod \  n_1 \\
                    x \equiv c_2 \  mod \  n_2\\
                    x \equiv c_3 \  mod \  n_3
                  \end{array}
                  \right.
          \]
          
          Using the Chinese Remainder Theorem, we can determine that $x = m^3$, and thus $m = \sqrt[3]{x}$. Also, if a message $m < n^{\frac{1}{e}}$ we can calculate the $e^{th}$ root of $(c=m^e)$ to get the plaintext message.
          
          It should be noted that this attack cannot be considered a "break" of the algorithm. Both these attacks can be mitigated through the use of salting -- adding randomly generated bits to messages before encryption. Another simple, but not recommended, solution is to make $e \geq 2^{16}+1$.
                    
          Due to the use of hashing and salting, this attack does not affect RSA cryptosystems such as RSA OAEP, the system implemented for Enigma.
        
      \paragraph{Key Exposure}
      \paragraph{Coppersmith's Short Pad Attack}
        \subparagraph{Hastad's Broadcast Attack}
      \paragraph{Related Message Attack}
      \paragraph{Forward Search Attack}
      \paragraph{Common Modulus Attack} 
      
        A previously common solution to managing the keys of multiple entities within one network was creating a central authority that would select a modulus $N$, and then share exponent pairs $e_i$ and $d_i$ with the entities. While this attack relies on the ability to factor prime multiples, given $(e_i,d_i)$, an attacker could determine the decryption exponents for all other entities within the network. 
      
      \paragraph{Cycling Attack}
      
        	
      
      \paragraph{Message Concealing}
    
    \subsubsection{System and Implementation Attacks}
      \paragraph{Timing}
      \paragraph{Random Faults}
      \paragraph{Bleichenbacher's Attack}
  
  \subsection{Certificates and Authentication}
  
    \subsubsection{Implementation Attacks}
    
      \paragraph{SSL BEAST}
    
      \paragraph{Authority Security and Impersonation}
      
        The underlying security of the certification system is based upon a trusted third party (TTP) that verifies the chain of trust -- the certificate authority (CA) -- and so ``a chain is only as strong as its weakest link" appears to be quite apt. If, through social or technical means, an attacker can gain access to the private keys or construction information for the private keys of a CA, they will be able to issue certificates as they wish until the breach is noticed and the CA can be removed from the chain.
    
        This is not a theoretical attack by any means. In July 2011, Mozilla -- the developers of many open source products such as Firefox and Thunderbird -- was informed that a fraudulent SSL certificate belonging to Google, Inc. had been issued by CA \emph{DigiNotar}. As it happens, DigiNotar's network had been breached allegedly without their knowledge, giving the attacker access to their private keys and thus allowing certificates to be issued arbitrarily. In this case, it was shown to be used by unknown entities in Iran to conduct a man-in-the-middle against Google services \cite{Google:2011ah}.

\section{Symmetric Cryptography}

  This sections covers attacks affecting the AES symmetric cipher.

  \subsection{Brute-force}
  \subsection{XSL Attack}
  \subsection{Biryukov and Khovratovich}
  \subsection{Related Key Attack}
  \subsection{Known-key Distinguishing Attack}
  \subsection{Bogdanov, Khovratovich, and Rechberger}
  \subsection{Side-channel attacks}

\section{Hash Functions}

  \subsection{Birthday Attacks}
  \subsection{Collision and Compression}
  \subsection{Chaining Attack}

\section{Emerging Threats}

  \subsection{Quantum Cryptography and Cryptanalysis}
  
    Quantum computing is an emerging technology.
    % Bits about quantum computing
    
    % Shor's algorithm
    
    As well as affecting algorithms based around the intractability of integer factorisation, quantum cryptanalysis also affects algorithms that utilise the discrete logarithm problem such as ElGamal, Diffie-Hellman and DSA.
    
    Quantum cryptography, in its current form, does not affect modern symmetric cryptographic algorithms -- neither ciphers or hash functions. Grover's algorithm, an algorithm that improves the efficiency of searching an unsorted database, improves the speed at which a symmetric cipher key can be cracked, however this is preventable using standard counter-actions such as increasing the key size. 
    
    An interesting current field of study is post-quantum cryptography: algorithms designed such that a cryptanalyst with a powerful quantum computer (should they become prevalent, or even plausibly workable in the future) cannot easily break. See \cite{Bernstein:2009aa}.
  
  \subsection{Ron was wrong, Whit is right}
  
    In early February 2012, a paper entitled ``Ron was wrong, Whit was right" -- a slight jab at RSA co-creator Ronald Rivest and nod towards cryptographer Whitfield Diffie -- swept through the headlines of the cryptographic communities. Written by researchers at the \emph{School of Computer and Communication Studies, \'{E}cole Polytechnique F\'{e}d\'{e}rale De Lausanne}. The paper detailed a "sanity check" of a subsection of RSA public keys that can be found online, and analysed them to test the randomness of the inputs used to calculate the keys.
    
    As we are now well aware, RSA is based entirely on the inability to efficiently factor prime numbers. However, there are other requirements for the good security of the algorithm. Namely, it is crucial that when the keys are generated, previous random numbers are not reused. \cite{Loebenberger:2011aa} states that: 
    
    Given a study of 11.7 million public keys, 
    
    Conversely, the researchers were unable to find any of the common exponents, used in RSA public keys, being used for the other two major public-key algorithms: DSA and ElGamal. ECDSA was also investigated, however only one certificate was found to be using ECDSA.
    
  \subsubsection{Sony PlayStation 3}
  
    An unrelated, yet high-profile, realisation of the risks of poor entropy in random number generators is the cracking of Sony's PlayStation 3 console. Sony used public-key cryptography to sign its bootloaders and games, which prevents unauthorised software being executed on the device. The overall system used to protect the device consists of many different techniques and algorithms, however it was the implementation of \emph{Elliptic Curve Digital Signature Algorithm (ECDSA)} that was flawed. As we will show below, a poorly executed random number generator design led to the extraction of the private key stored securely within the device, previously implausible to retrieve.
    
    ECDSA uses 11 parameters in its cryptographic algorithms: 9 public, and 2 private:
    
    \begin{center}
    \textbf{Public}
    
    $p, a, b, G, N =$  curve parameters
    
    $Q =$ public key
    
    $e =$ data hash
    
    $R, S =$ signature
    
    \textbf{Private}
    
    $m =$ random number
    
    $k =$ private key
    
    \end{center}
    
    The signature, $R, S$ is computed:
    
    \begin{center}
    
    $R = (mG)_x$
    
    $S = \frac{e+kR}{m}$
    
    \end{center}
    
    Because of this, it is absolutely vital that a high-entropy random number generator be used to produce $m$, otherwise given two signatures with the same $m$, we are able to determine $m$ \emph{and} private key $k$:
    
    \begin{center}
        \begin{tabular}{ c c }
          $R = (mG)_x$ & $R = (mG)_x$ \\
          $S_1 = \frac{e_1+kR}{m}$ & $S_2 = \frac{e_2+kR}{m}$
        \end{tabular}
    \end{center}
    
    Rearranging:
    \begin{center}
    	$S_1 - S_2 = \frac{e_1-e_2}{m}$
    
    	$m = \frac{e_1-e_2}{S_1-S_2}$
    
    	$\therefore k = \frac{e_1S_2-e_2S_1}{R(S_1-S_2)} = \frac{mS_n-e_n}{R}  $
    \end{center}
    
    Given $k$, we have now have the capability to sign arbitrary data, meaning: the chain of trust is broken, signed executables are no longer useful, encrypted storage can be accessed, and many other features of the security system rendered ineffective \cite{Bushing:2010qs}.
    
    While the human-impact was virtually zero in terms of loss of life, injury, etc. this is an excellent example of how something seemingly easy to implement like an RNG can affect the overall security of an entire system and the impact it can have.

\section{A comment on theory}

It is interesting to note, based upon history, that in all likelihood these theoretical attacks are currently being implemented. Though 

However, the topic of real-world security flaws and those that take advantage of them is extensive and could easily be covered by its own paper, if not several. It is left up to the reader's imagination to consider the many possible vulnerabilities currently being utilised unbeknownst to the vast majority of the community, and also to forget this idea lest they never use a networked device again.