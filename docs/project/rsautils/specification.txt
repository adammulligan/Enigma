Purpose
=============================

A set of command line utilities that generate RSA keys and
encrypt/decrypt data using them.

Binaries
=============================

* generate_keys
* encrypt
* decrypt

= Key File Format =

Public:
* Key Length
* Modulus
* Public Exponent

Private:
Requirements:
* Key length
* Modulus
* Public Exponent
* Private Exponent
* Prime1
* Prime2

Encryption
=============================

Scheme: RSAES-OAEP

$ encrypt -k keyfile.pub -f file_to_encrypt -o file_to_output_to

RSAES-OAEP-ENCRYPT ((n, e), M, L)

   Options:
   Hash     hash function (hLen denotes the length in octets of the hash
            function output)
   MGF      mask generation function

   Input:
   (n, e)   recipient's RSA public key (k denotes the length in octets
            of the RSA modulus n)
   M        message to be encrypted, an octet string of length mLen,
            where mLen <= k - 2hLen - 2
   L        optional label to be associated with the message; the
            default value for L, if L is not provided, is the empty
            string

   Output:
   C        ciphertext, an octet string of length k

   Errors:  "message too long"; "label too long"

   Assumption: RSA public key (n, e) is valid

   Steps:

   1. Length checking:

      a. If the length of L is greater than the input limitation for the
         hash function (2^61 - 1 octets for SHA-1), output "label too
         long" and stop.

      b. If mLen > k - 2hLen - 2, output "message too long" and stop.

   2. EME-OAEP encoding (see Figure 1 below):

      a. If the label L is not provided, let L be the empty string. Let
         lHash = Hash(L), an octet string of length hLen (see the note
         below).

      b. Generate an octet string PS consisting of k - mLen - 2hLen - 2
         zero octets.  The length of PS may be zero.

      c. Concatenate lHash, PS, a single octet with hexadecimal value
         0x01, and the message M to form a data block DB of length k -
         hLen - 1 octets as

            DB = lHash || PS || 0x01 || M.

      d. Generate a random octet string seed of length hLen.

      e. Let dbMask = MGF(seed, k - hLen - 1).

      f. Let maskedDB = DB \xor dbMask.

      g. Let seedMask = MGF(maskedDB, hLen).

      h. Let maskedSeed = seed \xor seedMask.

      i. Concatenate a single octet with hexadecimal value 0x00,
         maskedSeed, and maskedDB to form an encoded message EM of
         length k octets as

            EM = 0x00 || maskedSeed || maskedDB.

   3. RSA encryption:

      a. Convert the encoded message EM to an integer message
         representative m (see Section 4.2):

            m = OS2IP (EM).

      b. Apply the RSAEP encryption primitive (Section 5.1.1) to the RSA
         public key (n, e) and the message representative m to produce
         an integer ciphertext representative c:

            c = RSAEP ((n, e), m).

      c. Convert the ciphertext representative c to a ciphertext C of
         length k octets (see Section 4.1):

            C = I2OSP (c, k).

   4. Output the ciphertext C.

   Note.  If L is the empty string, the corresponding hash value lHash
   has the following hexadecimal representation for different choices of
   Hash:

   SHA-1:   (0x)da39a3ee 5e6b4b0d 3255bfef 95601890 afd80709
   SHA-256: (0x)e3b0c442 98fc1c14 9afbf4c8 996fb924 27ae41e4 649b934c
                a495991b 7852b855
   SHA-384: (0x)38b060a7 51ac9638 4cd9327e b1b1e36a 21fdb711 14be0743
                4c0cc7bf 63f6e1da 274edebf e76f65fb d51ad2f1 4898b95b
   SHA-512: (0x)cf83e135 7eefb8bd f1542850 d66d8007 d620e405 0b5715dc
                83f4a921 d36ce9ce 47d0d13c 5d85f2b0 ff8318d2 877eec2f
                63b931bd 47417a81 a538327a 

Decryption
=============================

Scheme: RSAES-OAEP

$ decrypt -k keyfile -f file_to_decrypt -o file_to_output_to

RSAES-OAEP-DECRYPT (K, C, L)

   Options:
   Hash     hash function (hLen denotes the length in octets of the hash
            function output)
   MGF      mask generation function

   Input:
   K        recipient's RSA private key (k denotes the length in octets
            of the RSA modulus n)
   C        ciphertext to be decrypted, an octet string of length k,
            where k = 2hLen + 2
   L        optional label whose association with the message is to be
            verified; the default value for L, if L is not provided, is
            the empty string

   Output:
   M        message, an octet string of length mLen, where mLen <= k -
            2hLen - 2

   Error: "decryption error"

   Steps:

   1. Length checking:

      a. If the length of L is greater than the input limitation for the
         hash function (2^61 - 1 octets for SHA-1), output "decryption
         error" and stop.

      b. If the length of the ciphertext C is not k octets, output
         "decryption error" and stop.

      c. If k < 2hLen + 2, output "decryption error" and stop.

   2.    RSA decryption:

      a. Convert the ciphertext C to an integer ciphertext
         representative c (see Section 4.2):

            c = OS2IP (C).

         b. Apply the RSADP decryption primitive (Section 5.1.2) to the
         RSA private key K and the ciphertext representative c to
         produce an integer message representative m:

            m = RSADP (K, c).

         If RSADP outputs "ciphertext representative out of range"
         (meaning that c >= n), output "decryption error" and stop.

      c. Convert the message representative m to an encoded message EM
         of length k octets (see Section 4.1):

            EM = I2OSP (m, k).

   3. EME-OAEP decoding:

      a. If the label L is not provided, let L be the empty string. Let
         lHash = Hash(L), an octet string of length hLen (see the note
         in Section 7.1.1).

      b. Separate the encoded message EM into a single octet Y, an octet
         string maskedSeed of length hLen, and an octet string maskedDB
         of length k - hLen - 1 as

            EM = Y || maskedSeed || maskedDB.

      c. Let seedMask = MGF(maskedDB, hLen).

      d. Let seed = maskedSeed \xor seedMask.

      e. Let dbMask = MGF(seed, k - hLen - 1).

      f. Let DB = maskedDB \xor dbMask.

      g. Separate DB into an octet string lHash' of length hLen, a
         (possibly empty) padding string PS consisting of octets with
         hexadecimal value 0x00, and a message M as

            DB = lHash' || PS || 0x01 || M.

         If there is no octet with hexadecimal value 0x01 to separate PS
         from M, if lHash does not equal lHash', or if Y is nonzero,
         output "decryption error" and stop.  (See the note below.)

   4. Output the message M.

   Note.  Care must be taken to ensure that an opponent cannot
   distinguish the different error conditions in Step 3.g, whether by
   error message or timing, or, more generally, learn partial
   information about the encoded message EM.  Otherwise an opponent may
   be able to obtain useful information about the decryption of the
   ciphertext C, leading to a chosen-ciphertext attack such as the one
   observed by Manger [36].

Data Conversion Primitives
=============================

= I2OSP =

   I2OSP converts a nonnegative integer to an octet string of a
   specified length.

   I2OSP (x, xLen)

   Input:
   x        nonnegative integer to be converted
   xLen     intended length of the resulting octet string

   Output:
   X        corresponding octet string of length xLen

   Error: "integer too large"

   Steps:

   1. If x >= 256^xLen, output "integer too large" and stop.

   2. Write the integer x in its unique xLen-digit representation in
      base 256:

         x = x_(xLen-1) 256^(xLen-1) + x_(xLen-2) 256^(xLen-2) + ...
         + x_1 256 + x_0,

      where 0 <= x_i < 256 (note that one or more leading digits will be
      zero if x is less than 256^(xLen-1)).

   3. Let the octet X_i have the integer value x_(xLen-i) for 1 <= i <=
      xLen.  Output the octet string

         X = X_1 X_2 ... X_xLen.

= OS2IP =

   OS2IP converts an octet string to a nonnegative integer.

   OS2IP (X)

   Input:
   X        octet string to be converted

   Output:
   x        corresponding nonnegative integer

Crypto Primitives
=============================

= RSAEP =

   RSAEP ((n, e), m)

   Input:
   (n, e)   RSA public key
   m        message representative, an integer between 0 and n - 1

   Output:
   c        ciphertext representative, an integer between 0 and n - 1

   Error: "message representative out of range"

   Assumption: RSA public key (n, e) is valid

   Steps:

   1. If the message representative m is not between 0 and n - 1, output
      "message representative out of range" and stop.

   2. Let c = m^e mod n.

   3. Output c.

= RSADP =

   RSADP (K, c)

   Input:
   K        RSA private key, where K has one of the following forms:
            - a pair (n, d)
            - a quintuple (p, q, dP, dQ, qInv) and a possibly empty
              sequence of triplets (r_i, d_i, t_i), i = 3, ..., u
   c        ciphertext representative, an integer between 0 and n - 1

   Output:
   m        message representative, an integer between 0 and n - 1

   Error: "ciphertext representative out of range"

   Assumption: RSA private key K is valid

   Steps:

   1. If the ciphertext representative c is not between 0 and n - 1,
      output "ciphertext representative out of range" and stop.

   2. The message representative m is computed as follows.

      a. If the first form (n, d) of K is used, let m = c^d mod n.

      b. If the second form (p, q, dP, dQ, qInv) and (r_i, d_i, t_i)
         of K is used, proceed as follows:

         i.    Let m_1 = c^dP mod p and m_2 = c^dQ mod q.

         ii.   If u > 2, let m_i = c^(d_i) mod r_i, i = 3, ..., u.

         iii.  Let h = (m_1 - m_2) * qInv mod p.

         iv.   Let m = m_2 + q * h.

         v.    If u > 2, let R = r_1 and for i = 3 to u do

                  1. Let R = R * r_(i-1).

                  2. Let h = (m_i - m) * t_i mod r_i.

                  3. Let m = m + R * h.

   3.   Output m.

   Note.  Step 2.b can be rewritten as a single loop, provided that one
   reverses the order of p and q.  For consistency with PKCS #1 v2.0,
   however, the first two primes p and q are treated separately from
   the additional primes.

Hash Functions
=============================

Mask generation functions

   A mask generation function takes an octet string of variable length
   and a desired output length as input, and outputs an octet string of
   the desired length.  There may be restrictions on the length of the
   input and output octet strings, but such bounds are generally very
   large.  Mask generation functions are deterministic; the octet string
   output is completely determined by the input octet string.  The
   output of a mask generation function should be pseudorandom: Given
   one part of the output but not the input, it should be infeasible to
   predict another part of the output.  The provable security of RSAES-
   OAEP and RSASSA-PSS relies on the random nature of the output of the
   mask generation function, which in turn relies on the random nature
   of the underlying hash.

   One mask generation function is given here: MGF1, which is based on a
   hash function.  MGF1 coincides with the mask generation functions
   defined in IEEE Std 1363-2000 [26] and the draft ANSI X9.44 [1].
   Future versions of this document may define other mask generation
   functions.

= MGF1 =

   MGF1 is a Mask Generation Function based on a hash function.

   MGF1 (mgfSeed, maskLen)

   Options:
   Hash     hash function (hLen denotes the length in octets of the hash
            function output)

   Input:
   mgfSeed  seed from which mask is generated, an octet string
   maskLen  intended length in octets of the mask, at most 2^32 hLen

   Output:
   mask     mask, an octet string of length maskLen

   Error:   "mask too long"

   Steps:

   1. If maskLen > 2^32 hLen, output "mask too long" and stop.

   2. Let T be the empty octet string.

   3. For counter from 0 to \ceil (maskLen / hLen) - 1, do the
      following:

      a. Convert counter to an octet string C of length 4 octets (see
         Section 4.1):

            C = I2OSP (counter, 4) .

      b. Concatenate the hash of the seed mgfSeed and C to the octet
         string T:

            T = T || Hash(mgfSeed || C) .

   4. Output the leading maskLen octets of T as the octet string mask.